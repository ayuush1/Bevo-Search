# -*- coding: utf-8 -*-
#! .\iris-env\Scripts\Activate
"""AppFunctions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wv_sQSbc1W2i-pDvM-8yPxo1KpT9sJXb

# Helpful links:
Database connection:
https://docs.intersystems.com/irislatest/csp/docbook/DocBook.UI.Page.cls?KEY=BPYNAT_pyapi

SQL:
https://docs.intersystems.com/irislatest/csp/docbook/DocBook.UI.Page.cls?KEY=RSQL_createtable

Data Types:
https://docs.intersystems.com/irislatest/csp/docbook/DocBook.UI.Page.cls?KEY=RSQL_datatype

# Loading the data to a dataframe
This tutorial covers how to use IRIS as a vector database.

For this tutorial, we will use a dataset of 2.2k online reviews of scotch (
dataset from https://www.kaggle.com/datasets/koki25ando/22000-scotch-whisky-reviews) . With our latest vector database functionality, we can leverage the latest embedding models to run semantic search on the online reviews of scotch whiskeys. In addition, we'll be able to apply filters on columns with structured data. For example, we will be able to search for whiskeys that are priced under $100, and are 'earthy, smooth, and easy to drink'. Let's find our perfect whiskey!
"""

"""# IRIS database operations"""
import pandas as pd
import iris
import time
import os

"""## Database connection settings"""

username = 'demo'
password = 'demo'
hostname = os.getenv('IRIS_HOSTNAME', 'localhost')
port = '1972'
namespace = 'USER'
CONNECTION_STRING = f"{hostname}:{port}/{namespace}"

print(CONNECTION_STRING)

# Note: Ideally conn and cursor should be used with context manager or with try-execpt-finally
conn = iris.connect(CONNECTION_STRING, username, password)
cursor = conn.cursor()

"""## Creating a new table"""


#file_path = os.path.expanduser('./emails_received.csv')

from sentence_transformers import SentenceTransformer

# Load a pre-trained sentence transformer model. This model's output vectors are of size 384
model = SentenceTransformer('all-MiniLM-L6-v2')

def Preprocessing():
    # Expand the tilde to the full path
    
    # Load the CSV file
    df = pd.read_csv('./emails_received.csv')

    df['Combined'] = df['From'] + df['Subject'] + df['Message']

    # View the data
    df.head()

    # # Clean data
    # # Remove the specified columns
    # df.drop(['currency'], axis=1, inplace=True)

    # # Drop the first column
    # df.drop(columns=df.columns[0], inplace=True)

    # # Remove rows without a price
    # df.dropna(subset=['price'], inplace=True)

    # # Ensure values in 'price' are numbers
    # df = df[pd.to_numeric(df['price'], errors='coerce').notna()]

    # Replace NaN values in other columns with an empty string
    df.fillna('', inplace=True)

    # View cleaned data
    df.head()

    tableName = "SchemaName.TableName"
    tableDefinition = "(From_Email VARCHAR(255), Subject VARCHAR(255), Message VARCHAR(50000), Combined VARCHAR(50000))"

    try:
        cursor.execute(f"DROP TABLE {tableName}")
    except:
        pass
    cursor.execute(f"CREATE TABLE {tableName} {tableDefinition}")

    """This created table can be viewed by going to the IRIS management portal at: http://localhost:52773/csp/sys/UtilHome.csp

    Note: When you create a table and specify the desired data fields, a RowID field is automatically created
    https://docs.intersystems.com/irisforhealthlatest/csp/docbook/DocBook.UI.Page.cls?KEY=GSQL_tables#GSQL_tables_idfield

    ## Adding a batch of data
    """

    # ## batch update
    # sql = f"Insert into {tableName} (name, category, review_point, price, description) values (?,?,?,?,?)"
    # params = [("FAKE BRAND","NOT A SCOTCH", "100", "100.00", "FAKE BRAND INSERTED TO TEST BATCH UPDATE"), ("FAKE BRAND 2","NOT A SCOTCH", "100", "100.00", "SECOND FAKE BRAND INSERTED TO TEST BATCH UPDATE"), ("FAKE BRAND 3","NOT A SCOTCH", "100", "100.00", "THIRD FAKE BRAND INSERTED TO TEST BATCH UPDATE")]
    # cursor.executemany(sql, params)

    """The above statement adds three new rows to the table as can be seen in this image:
    ![image.png](attachment:dd96760e-11b1-44c2-99ac-6bc1e0e355dd.png)

    ## Deleting rows
    """

    # sql = f"DELETE FROM {tableName} WHERE ID = 2"
    # cursor.execute(sql)

    """We see that the above statement deletes row 1 as can be seen from the final table:

    ![image.png](attachment:0135399a-a1ae-4d8f-9e17-1f070ef4a8ab.png)

    ## Delete entire table
    """

    # try:
    #     cursor.execute(f"DROP TABLE {tableName}")
    # except:
    #     pass

    """## Adding data one row at a time by looping over the dataframe"""

    # ## create table as it was deleted in last step:
    # cursor.execute(f"CREATE TABLE {tableName} {tableDefinition}")

    ##looping through dataframe and adding all the data to IRIS table
    sql = f"Insert into {tableName} (From_Email, Subject, Message, Combined) values (?,?,?,?)"
    start_time = time.time()
    for index,row in df.iterrows():
        data = (row['From'], row['Subject'], row['Message'], row['Combined'])
        cursor.execute(sql, data)
    end_time = time.time()
    print(f"time taken to add {len(df)} entries: {end_time-start_time} seconds")

    """## Reading from the table"""

    # ## Read only select columns
    # cursor.execute(f"select From_Email, Subject, Message, Combined from {tableName}")
    # fetched_data = cursor.fetchmany(3)
    # for row in fetched_data:
    #     print(row)

    # ##fetching all columns from database
    # cursor.execute(f"select * from {tableName}")
    # fetched_data = cursor.fetchmany(3)
    # for row in fetched_data:
    #     print(row)

    """# Adding vector embeddings to the table

    ## Create embeddings for the descriptions and add to the dataframe
    """

    # Generate embeddings for all descriptions at once. Batch processing makes it faster
    embeddings = model.encode(df['Combined'].tolist(), normalize_embeddings=True)

    # Add the embeddings to the DataFrame
    df['Combined_vector'] = embeddings.tolist()

    df.head()

    """## Delete and create the table in IRIS again to add embeddings
    ### (Note: Alternately, the Alter Table command can be used to just add the new embeddings column : https://docs.intersystems.com/irislatest/csp/docbook/DocBook.UI.Page.cls?KEY=RSQL_altertable#RSQL_altertable_synopsis )
    """

    try:
        cursor.execute(f"DROP TABLE {tableName}")
    except:
        pass

    ## note the additional description_vector VECTOR(DOUBLE, 384) field to store embeddings
    tableName = "SchemaName.TableName"
    tableDefinition = "(From_Email VARCHAR(255), Subject VARCHAR(255), Message VARCHAR(50000), Combined VARCHAR(50000), Combined_vector VECTOR(DOUBLE, 384))"
    cursor.execute(f"CREATE TABLE {tableName} {tableDefinition}")

    """## Add all the rows to the table in IRIS

    ### Adding the entire dataframe as a single batch (faster)
    """

    sql = f"""
        Insert into {tableName}
        (From_Email, Subject, Message, Combined, Combined_vector)
        values (?,?,?,?,TO_VECTOR(?))
    """

    start_time = time.time()
    # Prepare the list of tuples (parameters for each row)
    data = [
        (
            row['From'],
            row['Subject'],
            row['Message'],
            row['Combined'],
            str(row['Combined_vector'])
        )
        for index, row in df.iterrows()
    ]

    cursor.executemany(sql, data)
    end_time = time.time()
    print(f"time taken to add {len(df)} entries: {end_time-start_time} seconds")

    """### Adding one row at a time (slower)"""

    # try:
    #     cursor.execute(f"DROP TABLE {tableName}")
    # except:
    #     pass


    # tableName = "SchemaName.TableName"

    # ## note the additional description_vector VECTOR(DOUBLE, 384) field to store embeddings
    # tableDefinition = "(name VARCHAR(255), category VARCHAR(255),review_point INT, price DOUBLE, description VARCHAR(2000), description_vector VECTOR(DOUBLE, 384))"
    # cursor.execute(f"CREATE TABLE {tableName} {tableDefinition}")

    # ## note the TO_VECTOR(?) used to add vector data type to the table
    # ## also note the "str" conversion of the embeddings from the dataframe before they are added to the table in IRIS
    # # sql = f"Insert into {tableName} (name, category, review_point, price, description, description_vector) values (?,?,?,?,?,TO_VECTOR(?))"
    # sql = f"""
    #     INSERT INTO {tableName}
    #     (name, category, review_point, price, description, description_vector)
    #     VALUES (?, ?, ?, ?, ?, TO_VECTOR(?))
    # """
    # start_time = time.time()
    # for index,row in df.iterrows():
    #     data = [(row['name'], row['category'], row['review.point'], row['price'], row['description'], str(row['description_vector']) )]
    #     cursor.execute(sql, data)
    # end_time = time.time()
    # print(f"time taken to add {len(df)} entries: {end_time-start_time} seconds")

"""# Using IRIS Vector Search

## Let's look for a scotch that costs less than $100, and has an earthy and creamy taste.
"""
def VecSearch():
    # Read 'input.txt'
    #file_path2 = os.path.expanduser('./input.txt')
    f = open("./input.txt", "r")
    searchPhrase = f.readline().strip()

    # This is our search phrase
    #searchPhrase = "hello i am asking you something"

    # Convert search phrase into a vector
    searchVector = model.encode(searchPhrase, normalize_embeddings=True).tolist()

    # Define the SQL query with placeholders for the vector and limit
    numberOfResults = f.readline().strip()
    ordering = f.readline().strip() # DESC or ASC

    tableName = "SchemaName.TableName"

    sql = f"""
        SELECT TOP ? From_Email, Subject, Message
        FROM {tableName}
        ORDER BY VECTOR_DOT_PRODUCT(Combined_vector, TO_VECTOR(?)) {ordering}
    """

    # Execute the query with the number of results and search vector as parameters
    cursor.execute(sql, [numberOfResults, str(searchVector)])
    
    f.close()
    f2 = open('./result.txt', 'w')

    # Fetch all results
    results = cursor.fetchall()
    for row in results:
        print(row)
        f2.write(str(row) + '\n')

    f2.close()

    # f3 = open('result.txt', 'r')
    # print(f3.readline())
    # print(f3.readline())
    # print(f3.readlines())

Preprocessing()
VecSearch()

